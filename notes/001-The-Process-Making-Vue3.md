# After Reading "The process: Making Vue 3" #

  <https://increment.com/frontend/making-vue-3>

  2018下半年就已萌生开发新版本的想法, 主要有两点考虑让我们想要重写Vue:
    1. 主流浏览器普遍支持的新语言特性的能力
    2. 当前代码的设计与结构问题逐渐暴露

## 为什么重写 ##

### 新语言特性 ###

  Proxy允许我们拦截对象的操作, 消除了Vue现有的限制(比如无法检测属性增加), 也提供了更好的性能
  `N: Proxy 的能力 再详细了解一下`

### 解决架构问题 ###

  由于当前架构的限制, 积累了许多难以解决的问题. 在现有代码基础上解决这些问题需要的重构努力 几乎等同于重写
    1. 书写模板编译器的方式让适当的源映射支持变得很有挑战性 `Q: 要怎么做映射呢?`
        2. 为了构建高级渲染器以使能够渲染在非DOM平台, 需要做很多工作: fork并重复很多代码 `Q: Vue3 是怎么解决的?`
      我们积累了各种内部模块和浮动代码之间的隐式耦合形式的技术负债, 这使得单独理解代码库的一部分变得困难.
      贡献者们很少有信心做出重要的改变
      重写给我们重写考虑代码组织的机会

## 初始原型阶段 ##

  在这个阶段, 我们致力于为进一步开发打下坚实基础

### 切换到 typescript ###

  类型检查极大的减少了重构时产生意外bug的机会, 并帮助贡献者更有信心的做出重大改变
  越来越多用户同时使用Vue和Typescript
  切换到typescript允许我们自动生成声明文件, 减轻了维护负担
  `N: 需要安排时间加强学习Typescript了`

### 解耦内部包 ###

  采用monorepo进行构建, 框架由内部包组成, 每个包都有自己的api、类型定义和测试
  模块间依赖更加单一, 可读性更高
  这是努力降低项目贡献壁垒和提高长期可维护的关键
  `Q: monorepo 是啥样的工具, 如何进行包管理的?`

### 建立RFC(征求意见)程序 ###

  是时候将粗糙的设计草稿转化成详细具体的设计了
  Vue的广泛使用意味着重大变化可能导致用户的大规模迁移成本和潜在的生态系统分裂
  RFC程序被证明非常有用, 它作为一个思想框架, 迫使我们充分考虑潜在更改的方方面面, 并允许我们的社区参与设计过程, 提交经过深思熟虑的特性请求.
  `N: Vue3才有的吗, 太好了`

## 更快更小 ##

  性能对前端框架来说至关重要. 尽管Vue2在性能上已经很有竞争力, 重写后新的渲染策略提供了更进一步的机会
  `Q: 和Vue2的渲染策略有什么不同? (需要好好研究源码对比一下)`

### 克服虚拟DOM的瓶颈 ###

​      Vue有一个相当独特的渲染策略: 提供类似HTML的模板语法, 编译模板成为渲染函数, 渲染函数会生成虚拟DOM树. 框架通过递归遍历两个虚拟DOM树和比对每一个节点的每一个属性来计算出真实DOM的哪些部分需要更新. 由于现代JavaScript引擎进行了高级优化, 这种粗糙的算法通常非常快速, 但更新仍然涉及了许多不必要的CPU工作. 当模板有大量静态内容和极少动态绑定时, 这种低效率就特别明显 -- 整个虚拟DOM数仍然需要递归循环来得出哪里地方改变了.
​    模板编译步骤可以进行静态分析, 提取出动态部分的信息. Vue2通过跳过静态子树在某种程度上做到了这一点, 但由于编译器架构过分简单, 很难实现更高级的优化. `N: 阅读过Vue2 编译和优化部分的代码, 确实有点简单了`
  Vue3使用适当的AST转换管道重写了编译器, 它允许我们以转换插件的形式组合编译时优化. `Q: 插件? 如何做`
  希望找到一个消除尽可能多开销的渲染策略.
​       一个选项是, 抛弃虚拟DOM, 直接生成命令式的DOM操作, 但这会失去直接编写虚拟DOM渲染函数的能力, 而这个能力对高级用户和库作者是非常有价值的, 而且这是一个巨大的改变
​      另一个则是去掉不必要的虚拟DOM遍历和属性对比, 这些往往是更新期间最大的性能开销. 编译器和运行时需要合作. 编译器分析模板并生成具有优化提示的代码 `N: shapeFlag patchFlag`, 运行时获取提示并使用尽可能采用最快的路径.

有三个主要的优化:
    1. 在树的层次, 在模板缺少可以动态修改节点结构的指令(v-if, v-for)时, 节点结构是完全静态的. 如果通过结构性指令将模板分为嵌套的块, 块内的节点结构又变为完全静态. 在块内更新节点时, 不再需要递归遍历树 -- 块内动态绑定可以在平面数组中跟踪 `Q: ? (需要看下源码)`. 这个优化 通过减少一个数量级的树的遍历 规避了大量的虚拟DOM开销.
        2. 编译器主动检测静态节点, 子树, 甚至模板中的数据对象, 将他们提取到生成代码中的渲染函数外. 避免在每次渲染师重新创建对象, 极大提高内存使用和减少垃圾收集频率 `Q: 编译结果是什么样子的? (看源码实现细节)`
        3. 在元素的层次, 编译器基于需要执行的更新类型 为每一个拥有动态绑定的元素 生成一个优化标记. 比如一个元素有一个动态的class绑定和许多静态属性, 将会得出一个表明只需要检查class的标记. 运行时将收集这些提示并采用专用的快速路径. `N: shapeFlag`
        结合这些技术, Vue 3占用的CPU时间不到Vue 2的十分之一, 极大地改善了我们的渲染更新基准测试

### 最小化包大小 ###

  框架大小也会影响性能.  Vue 2的运行时大小约为23 KB. 有两个问题:
    1. 不是每个人都用到框架的所有特性
    2. 随着新特性的添加, 框架会无限地增长
  `N: 按需引入 tree-shaking`
  用户应该能够在构建时删除未使用的框架特性的代码, 并且只为他们使用的内容付出代价
  Vue3通过将大部分全局api和内部帮助函数移动到ES模块导出来实现这一点. 现代打包器会静态地分析模块依赖关系, 并删除与未使用代码.
  框架的某些必不可少的部分永远不会被tree-shaking. 我们将这些不可或缺部分的度量称为基线大小. 尽管添加了许多新特性, 但Vue 3的基线大小约为10 KB, 还不到Vue 2的一半.

## 解决规模需求 ##

  提高Vue处理大规模应用程序的能力. 类型系统(TypeScript)和简洁的组织可重用代码 非常重要.
   Composition API . 与通过指定一长串选项来定义组件不同, Composition API允许用户像编写函数一样自由地表达、组合和重用有状态组件逻辑, 同时提供出色的TypeScript支持.

## 寻求平衡 ##

  各种各样级别的用户, 各种各样的需求, 各种各样的使用场景.
  Vue的设计不断被这些需求塑造和告知, 因为我们寻求在各种权衡之间取得平衡.

  还有很多工作要做, 最重要的是更新支持库、文档和工具, 以确保顺利迁移

